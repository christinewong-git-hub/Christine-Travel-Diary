<script>
  const { createApp } = Vue;
  // **æ³¨æ„: è«‹å°‡æ­¤æ›¿æ›ç‚ºæ‚¨å¯¦éš›çš„ AviationStack Key**
  const AVIATIONSTACK_KEY = '5bxxxxxxxxx'; 
  
  const GeocodingCache = {};
  
  // ğŸ”¥ ã€æ›¿æ›ç‚ºæ‚¨çš„ Firebase é…ç½®ã€‘
  const firebaseConfig = {
    apiKey: "AIzaSyCeFnypnf5WdO9mIsuwLwGZIsEv123QcuM", 
    authDomain: "my-travel-diary-1dbc0.firebaseapp.com",
    projectId: "my-travel-diary-1dbc0",
    storageBucket: "my-travel-diary-1dbc0.firebasestorage.app",
    messagingSenderId: "592971246262",
    appId: "1:592971246262:web:f7d0c923b697a26e199417",
    // measurementId: "G-F6X3YWL2MY" 
  };

  // ğŸ”¥ Firebase åˆå§‹åŒ– (ä¿ç•™ V8 æ¨¡å¼ï¼Œä»¥ç¢ºä¿æ‰€æœ‰åŠŸèƒ½å…¼å®¹)
  const app = firebase.initializeApp(firebaseConfig);
  const auth = app.auth();
  const db = app.firestore();


  createApp({
    data() {
      return {
        activeTab: 'info',
        trips: [],
        activeTripId: null,
        showTripModal: false,
        editingTripId: null,
        tempTrip: {},
        map: null,
        weatherData: null,
        weatherTheme: 'sunny',
        showBatchImport: false,
        batchImportText: '',
        
        chartInstance: null,
        
        newExpense: { 
          id: null, 
          name: '', 
          localAmount: null, // ç¶å®šå­—ä¸²
          amount: null,      
          method: 'ç¾é‡‘', 
          category: 'é£²é£Ÿ', 
          day: 1, 
        },
        inputCurrency: '', 
        
        newShoppingItem: { 
            name: '', 
            onlinePrice: null, // é è¨ˆç‚º HKD
            localPrice: null,  // é è¨ˆç‚ºç•¶åœ°å¹£åˆ¥é‡‘é¡
            quantity: 1,       // æ•¸é‡æ¬„ä½
            bought: false, 
            image: '' 
        },
        
        activeDay: 1, // è¡Œç¨‹é é¢å°ˆç”¨

        // ğŸ”¥ Firebase/Auth ç›¸é—œç‹€æ…‹è®Šæ•¸
        currentUser: null,       
        loginEmail: '',          
        loginPassword: '',       
        showLoginModal: false, 

        // ğŸ”¥ æ–°å¢æš«å­˜åŒ¯ç‡è®Šæ•¸
        tempExchangeRate: null,

        tabs: [
          { id: 'info', label: 'Trip Info', icon: 'ri-information-line' },
          { id: 'itinerary-map', label: 'è¡Œç¨‹', icon: 'ri-map-pin-user-line' },
          { id: 'budget', label: 'è¨˜å¸³', icon: 'ri-wallet-3-line' },
          { id: 'shopping', label: 'è³¼ç‰©', icon: 'ri-shopping-bag-3-line' },
          { id: 'trips', label: 'History', icon: 'ri-suitcase-line' },
        ]
      };
    },
    computed: {
      activeTrip() { return this.trips.find(t => t.id === this.activeTripId) || null; },
      
      totalDays() {
          if (!this.activeTrip || !this.activeTrip.startDate || !this.activeTrip.endDate) return 1;
          const start = new Date(this.activeTrip.startDate);
          const end = new Date(this.activeTrip.endDate);
          const diffTime = Math.abs(end - start);
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; 
          return diffDays > 0 ? diffDays : 1;
      },

      groupedItinerary() {
        if (!this.activeTrip) return [];
        
        const days = Array.from({ length: this.totalDays }, (_, i) => ({ day: i + 1, items: [] }));
        
        this.activeTrip.itinerary
            .sort((a, b) => (a.day || 1) - (b.day || 1)) 
            .forEach(item => {
                const dayIndex = (item.day || 1) - 1; 
                if (dayIndex >= 0 && dayIndex < days.length) { 
                    days[dayIndex].items.push(item);
                }
            });
            
        days.forEach(day => {
             day.items.sort((a, b) => {
                 const timeA = a.time ? a.time.replace(':', '') : '9999';
                 const timeB = b.time ? b.time.replace(':', '') : '9999';
                 return timeA - timeB;
             });
        });
        
        return days;
      },
      
      filteredExpenses() {
          if (!this.activeTrip || !this.activeTrip.expenses) {
              return [];
          }
          return this.activeTrip.expenses; 
      },

      totalExpensesHKD() {
        if (!this.activeTrip) return 0;
        return this.filteredExpenses.reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
      },

      weatherDesc() {
        if (!this.weatherData) return 'Loading...';
        const code = this.weatherData.weathercode;
        const map = { 0:'æ™´æœ— Sunny', 1:'å¤šé›² Cloudy', 2:'é™°å¤© Overcast', 3:'æ¯›æ¯›é›¨ Drizzle', 45:'éœ§ Fog', 48:'éœ§æ· Rime fog', 51:'æ¯›æ¯›é›¨ Drizzle', 53:'å°é›¨ Light Rain', 55:'å¤§é›¨ Heavy Rain', 61:'é™£é›¨ Rain', 63:'ä¸­é›¨ Moderate Rain', 65:'å¤§é›¨ Heavy Rain', 80:'é™£é›¨ Showers', 81:'ä¸­åº¦é™£é›¨ Moderate Showers', 82:'å¼·çƒˆé™£é›¨ Violent Showers', 95:'é›·æš´ Thunderstorm' };
        return map[code] || 'å¤šé›² Cloudy';
      },
      
      // ğŸ”¥ é—œéµä¿®æ­£é» 1: ç¢ºä¿ localAmount è¢«å¼·åˆ¶æ¸…ç†ï¼Œä¸¦åœ¨ HKD æ™‚ç›´æ¥ä½¿ç”¨
      finalHKDAmount() {
          // ã€å¼·åˆ¶æ¸…ç†å’Œè½‰æ›ã€‘ä½¿ç”¨ä¸€å€‹æ›´åš´æ ¼çš„æ–¹æ³•ä¾†ç¢ºä¿ newExpense.localAmount æ˜¯æœ‰æ•ˆçš„æ•¸å­—
          // ç§»é™¤æ‰€æœ‰éæ•¸å­—å’Œå°æ•¸é»çš„å­—ç¬¦
          const localAmountStr = String(this.newExpense.localAmount || '').replace(/[^0-9.]/g, '');
          const amount = Number(localAmountStr);
          
          if (!this.activeTrip || isNaN(amount) || amount <= 0) {
              return 0;
          }
          
          // ç•¶é¸æ“‡ HKD æ™‚ï¼Œç›´æ¥è¿”å›é‡‘é¡ (å³ç‚º HKD)
          if (this.inputCurrency === 'HKD') {
              return parseFloat(amount.toFixed(2));
          }
          
          // è™•ç†å¤–å¹£è½‰æ›é‚è¼¯
          const rate = this.activeTrip.exchangeRate;
          if (!rate || rate <= 0) {
               // å¦‚æœæ˜¯å¤–å¹£ä½†åŒ¯ç‡ç„¡æ•ˆï¼Œè¿”å› 0
               return 0;
          }
          
          // ç¢ºä¿è¿”å›çš„é‡‘é¡ä¿ç•™å…©ä½å°æ•¸
          return parseFloat((amount / rate).toFixed(2));
      },
      
      categorySummary() {
          if (!this.activeTrip || !this.filteredExpenses) {
              return { labels: [], data: [] };
          }
          const summary = this.filteredExpenses.reduce((acc, expense) => {
              const category = expense.category || 'å…¶ä»–';
              const amount = Number(expense.amount) || 0;
              acc[category] = (acc[category] || 0) + amount;
              return acc;
          }, {});
          
          const labels = Object.keys(summary);
          const data = Object.values(summary).map(val => parseFloat(val.toFixed(2)));
          
          return { labels, data };
      },

      paymentSummary() {
          const summary = { 'ç¾é‡‘': 0, 'ä¿¡ç”¨å¡': 0, 'å…¶ä»–': 0 };
          if (!this.activeTrip) return summary;

          this.filteredExpenses.forEach(exp => {
              const method = exp.method || 'ç¾é‡‘'; 
              const amount = Number(exp.amount) || 0;
              if (summary.hasOwnProperty(method)) {
                  summary[method] += amount;
              } else {
                  summary['å…¶ä»–'] += amount; 
              }
          });

          summary['ç¾é‡‘'] = parseFloat(summary['ç¾é‡‘'].toFixed(2));
          summary['ä¿¡ç”¨å¡'] = parseFloat(summary['ä¿¡ç”¨å¡'].toFixed(2));
          summary['å…¶ä»–'] = parseFloat(summary['å…¶ä»–'].toFixed(2));

          return summary;
      },
      
      activeBudgetDayText() {
          return 'æ‰€æœ‰'; 
      },

      groupedAndSortedExpenses() {
          if (!this.activeTrip || !this.activeTrip.expenses || this.activeTrip.expenses.length === 0) return [];

          const expenses = this.activeTrip.expenses.slice() 
              .sort((a, b) => (a.day === undefined ? 1 : a.day) - (b.day === undefined ? 1 : b.day));

          const result = [];
          
          const daysGrouped = expenses.reduce((acc, exp) => {
              const day = exp.day === undefined ? 1 : exp.day;
              if (!acc[day]) {
                  acc[day] = [];
              }
              acc[day].push(exp);
              return acc;
          }, {});

          const sortedDays = Object.keys(daysGrouped).map(Number).sort((a, b) => a - b);
          
          for (const day of sortedDays) {
              const dayExpenses = daysGrouped[day];
              
              const total = dayExpenses.reduce((sum, exp) => sum + (Number(exp.amount) || 0), 0);
              
              result.push({
                  isHeader: true,
                  day: day,
                  dayLabel: day === 0 ? 'æ—…è¡Œå‰ (Day 0)' : `Day ${day}`,
                  total: parseFloat(total.toFixed(2)),
                  id: `header-${day}`
              });

              result.push(...dayExpenses);
          }

          return result;
      },

      shoppingListWithSavings() {
          if (!this.activeTrip || !this.activeTrip.shoppingItems) return [];
          const rate = this.activeTrip.exchangeRate || 1; // 1 HKD = X å¤–å¹£

          const processedList = this.activeTrip.shoppingItems.map(item => {
              // ç¢ºä¿ quantity, localPrice, onlinePrice æ˜¯æœ‰æ•ˆæ•¸å­—
              const quantity = Math.max(1, Number(item.quantity) || 1);
              const localPrice = Number(item.localPrice) || 0;
              const onlinePrice = Number(item.onlinePrice) || 0;
              
              // 1. è¨ˆç®—ç•¶åœ°åƒ¹æ›ç®—æˆ HKD çš„ç¸½é¡ (å–®åƒ¹ / åŒ¯ç‡ * æ•¸é‡)
              // åªæœ‰ç•¶ localPrice å’Œ rate > 0 æ™‚æ‰è¨ˆç®—
              const localPriceHKD = (localPrice > 0 && rate > 0) 
                  ? parseFloat(((localPrice / rate) * quantity).toFixed(2)) 
                  : 0;
              
              // 2. è¨ˆç®—ç¶²ä¸Šåƒ¹ HKD çš„ç¸½é¡
              const onlinePriceHKD = onlinePrice * quantity;
              
              // 3. è¨ˆç®—ç¸½å…±ç¯€çœçš„é‡‘é¡ (ç¶²ä¸Šåƒ¹ - ç•¶åœ°åƒ¹æ›ç®— HKD)
              // åªæœ‰åœ¨å…©ç¨®åƒ¹æ ¼éƒ½å­˜åœ¨æ™‚æ‰è¨ˆç®—åƒ¹å·®
              const savingsHKD = (localPriceHKD > 0 && onlinePriceHKD > 0) 
                  ? parseFloat((onlinePriceHKD - localPriceHKD).toFixed(2))
                  : 0;

              return {
                  ...item,
                  quantity: quantity,
                  localPriceHKD: localPriceHKD, // 0.00 or actual price
                  onlinePriceHKD: parseFloat(onlinePriceHKD.toFixed(2)),
                  savingsHKD: savingsHKD,
              };
          });
          
          // æ’åºé‚è¼¯ï¼šæœªè²·çš„åœ¨å‰ï¼Œå…¶æ¬¡æŒ‰ç¯€çœé‡‘é¡é™åº
          return processedList.sort((a, b) => {
              if (a.bought === b.bought) {
                  return b.savingsHKD - a.savingsHKD; // æœªè²·çš„å‰‡æŒ‰ç¯€çœé‡‘é¡é™åº
              }
              return a.bought ? 1 : -1; // false (0) < true (1)ï¼Œæ‰€ä»¥æœªè²·çš„åœ¨å‰
          });
      },

      totalSavings() {
          return this.shoppingListWithSavings.reduce((sum, item) => sum + item.savingsHKD, 0);
      }
    },
    watch: {
      activeTab(newTab) {
        if (newTab === 'itinerary-map') {
          setTimeout(() => this.forceUpdateMap(), 500);
        } else if (newTab === 'budget') { 
          // è¼‰å…¥ tempExchangeRate
          this.tempExchangeRate = this.activeTrip?.exchangeRate || 1; 
          // ä¿®æ­£ï¼šç•¶åˆ‡æ›åˆ° Budget Tab æ™‚ï¼Œç¢ºä¿ inputCurrency è¢«è¨­ç‚º Trip çš„é è¨­å¤–å¹£
          this.inputCurrency = this.activeTrip.currency; 
          this.$nextTick(() => this.updateChart());
        }
      },
      activeTripId() {
        this.fetchWeather();
        this.activeDay = 1; 
        if (this.activeTrip) {
            this.inputCurrency = this.activeTrip.currency; 
            this.newExpense.day = 1; 
            // åˆå§‹åŒ– tempExchangeRate
            this.tempExchangeRate = this.activeTrip.exchangeRate || 1; 
        }
        this.updateChart(); 
      },
      activeDay() {
        this.forceUpdateMap();
      },
      
      categorySummary: {
          handler() {
              this.updateChart();
          },
          deep: true
      }
    },
    mounted() {
      // ç›£è½ Firebase ç™»å…¥ç‹€æ…‹
      auth.onAuthStateChanged(user => {
            if (user) {
                this.currentUser = user;
                this.showLoginModal = false;
                // ç™»å…¥æˆåŠŸå¾Œï¼Œå¾ Firestore è¼‰å…¥æ•¸æ“š
                this.loadData(); 
            } else {
                this.currentUser = null;
                // æœªç™»å…¥æ™‚ï¼Œå˜—è©¦è¼‰å…¥æœ¬åœ°æ•¸æ“šä¸¦å…è¨±ç€è¦½
                this.loadInitialOrLocalData(false); // åƒ…å¾æœ¬åœ°è¼‰å…¥ï¼Œä¸å˜—è©¦ä¸Šå‚³
                this.showLoginModal = false; // é è¨­éš±è—æ¨¡æ…‹æ¡†
            }
        });

      if (this.activeTrip) {
          this.inputCurrency = this.activeTrip.currency;
          this.newExpense.day = 1;
          this.newExpense.category = 'é£²é£Ÿ'; 
      }
    },
    methods: {
      selectDay(day) {
          this.activeDay = day;
      },
      
      // ğŸ”¥ saveData æª¢æŸ¥ç™»å…¥ç‹€æ…‹
      async saveData() { 
          // 1. å„²å­˜åˆ° LocalStorage (ä½œç‚ºå‚™ä»½)
          localStorage.setItem('christine_travel_diary_v4', JSON.stringify(this.trips));
          this.updateChart(); 
          
          if (!this.currentUser) {
              return; // æœªç™»å…¥æ™‚ï¼Œåªå„²å­˜æœ¬åœ°
          }
          
          // 2. å„²å­˜åˆ°é›²ç«¯ Firestore (åªæœ‰ç™»å…¥å¾Œæ‰åŸ·è¡Œ)
          if (this.currentUser && this.activeTrip) {
               try {
                   const userRef = db.collection('userTrips').doc(this.currentUser.uid);
                   await userRef.set({
                       trips: JSON.parse(JSON.stringify(this.trips)), // ç¢ºä¿æ•¸æ“šæ˜¯ç´”ç²¹çš„ JSON
                       activeTripId: this.activeTripId,
                       timestamp: firebase.firestore.FieldValue.serverTimestamp() // æ–°å¢æ™‚é–“æˆ³
                   });
                   // console.log("æ•¸æ“šæˆåŠŸå„²å­˜åˆ° Firestore!");
               } catch (e) {
                   console.error("Firestore å„²å­˜å¤±æ•—: ", e);
                   alert("æ•¸æ“šå„²å­˜åˆ°é›²ç«¯å¤±æ•—ï¼Œå·²å„²å­˜è‡³ç€è¦½å™¨æœ¬åœ°ã€‚è«‹æª¢æŸ¥ç¶²è·¯æˆ– Firestore è¦å‰‡ï¼");
               }
          }
      },
      
      // ğŸ”¥ loadData: å„ªå…ˆå¾ Firestore è¼‰å…¥
      async loadData() {
        if (!this.currentUser) {
            this.loadInitialOrLocalData(false);
            return;
        }

        try {
            const docSnap = await db.collection('userTrips').doc(this.currentUser.uid).get();
            
            if (docSnap.exists) {
                const data = docSnap.data();
                
                if (data.trips && data.trips.length > 0) {
                    this.trips = this.sanitizeLoadedTrips(data.trips);
                    this.activeTripId = data.activeTripId || (this.trips.length > 0 ? this.trips[0].id : null);
                    localStorage.setItem('christine_travel_diary_v4', JSON.stringify(this.trips));
                } else {
                    console.log("Firestore æ•¸æ“šç‚ºç©ºï¼Œå˜—è©¦è¼‰å…¥æœ¬åœ°æˆ–é è¨­æ•¸æ“šã€‚");
                    this.loadInitialOrLocalData(true);
                }
            } else {
                console.log("Firestore æ‰¾ä¸åˆ°æ–‡ä»¶ï¼Œè¼‰å…¥æœ¬åœ°æˆ–é è¨­æ•¸æ“šã€‚");
                this.loadInitialOrLocalData(true);
            }
        } catch (e) {
            console.error("Firestore è®€å–å¤±æ•—: ", e);
            alert("æ•¸æ“šè®€å–å¤±æ•—ï¼Œå·²å˜—è©¦è¼‰å…¥æœ¬åœ°æ•¸æ“šã€‚è«‹æª¢æŸ¥ç¶²è·¯æˆ– Firestore è¦å‰‡ï¼");
            this.loadInitialOrLocalData(false);
        }
        
        if (this.activeTripId) {
          this.fetchWeather();
          this.newExpense.day = 1;
          this.inputCurrency = this.activeTrip.currency; 
          // åˆå§‹åŒ– tempExchangeRate
          this.tempExchangeRate = this.activeTrip.exchangeRate || 1;
        }
      },
      
      // ğŸ”¥ loadInitialOrLocalData: è™•ç†é¦–æ¬¡ç™»å…¥æ™‚çš„æ•¸æ“š
      loadInitialOrLocalData(shouldUpload = false) {
          const savedLocal = localStorage.getItem('christine_travel_diary_v4');
          let parsedTrips = [];

          if (savedLocal) {
              parsedTrips = this.sanitizeLoadedTrips(JSON.parse(savedLocal));
              this.trips = parsedTrips;
          } else {
              // è¼‰å…¥é è¨­æ•¸æ“š
              const defaultItinerary = [{ id: Date.now(), day: 1, time: '10:00', activity: 'åˆ°é”æ©Ÿå ´', location: 'Narita Airport', mapLink: '' }];
              this.trips = [{
                id: Date.now(), title: 'Japan Trip', destination: 'Japan', city: 'Tokyo', currency: 'JPY',
                startDate: '2025-12-24', endDate: '2025-12-28',
                center: { lat: 35.6895, lng: 139.6917 }, exchangeRate: 19.2,
                flights: { outbound: { no: 'CX500', date: '2025-12-24' }, inbound: { no: 'CX501', date: '2025-12-28' } },
                itinerary: defaultItinerary, 
                expenses: [{ id: Date.now()+1, name: 'æ©Ÿç¥¨', amount: 3500, method: 'ä¿¡ç”¨å¡', category: 'æ—…è¡Œå‰', date: '12/10', day: 0, localAmount: 67200 }], 
                shoppingItems: [
                    { id: Date.now()+2, name: 'é˜²æ›¬éœœ', onlinePrice: 200, localPrice: 3000, quantity: 2, bought: false, image: '' },
                    { id: Date.now()+3, name: 'æ‰‹ä¿¡é¤…ä¹¾', onlinePrice: 150, localPrice: 2500, quantity: 3, bought: true, image: '' },
                ]
              }];
          }
          
          this.activeTripId = this.trips.length > 0 ? this.trips[0].id : null;
          
          if (shouldUpload && this.currentUser) {
              // å¦‚æœæ˜¯é¦–æ¬¡ç™»å…¥ï¼Œå°‡æœ¬åœ°æˆ–é è¨­æ•¸æ“šä¸Šå‚³åˆ°é›²ç«¯
              this.saveData(); 
          }

          // åˆå§‹åŒ– tempExchangeRate
          if (this.activeTrip) {
              this.tempExchangeRate = this.activeTrip.exchangeRate || 1;
          }
      },
      
      // ğŸ”¥ æ¸…ç†è¼‰å…¥æ•¸æ“šï¼Œç¢ºä¿æ‰€æœ‰æ¬„ä½å’Œ ID å®Œæ•´
      sanitizeLoadedTrips(rawTrips) {
          return rawTrips.map(trip => {
              if (trip.expenses) {
                  trip.expenses = trip.expenses.map(exp => ({ 
                      id: exp.id || Date.now() + Math.random(), 
                      amount: exp.amount || 0,
                      day: exp.day === undefined ? 1 : exp.day, 
                      ...exp 
                  }));
              } else {
                  trip.expenses = [];
              }
              if (trip.itinerary) {
                  trip.itinerary = trip.itinerary.map(item => ({ 
                      id: item.id || Date.now() + Math.random(), 
                      day: item.day || 1, 
                      mapLink: item.mapLink || '', 
                      ...item 
                  }));
              } else {
                  trip.itinerary = [];
              }
              if (trip.shoppingItems) {
                  trip.shoppingItems = trip.shoppingItems.map(item => ({
                      id: item.id || Date.now() + Math.random(),
                      quantity: item.quantity || 1, 
                      localPrice: item.localPrice || null, 
                      onlinePrice: item.onlinePrice || null, 
                      bought: item.bought || false, 
                      ...item
                  }));
              } else {
                  trip.shoppingItems = [];
              }
              return trip;
          });
      },

      calculateTripTotal(trip) {
        if (!trip.expenses) return 0;
        return trip.expenses.reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
      },
      
      calculateDayTotal(dayIndex) {
          if (!this.activeTrip || !this.activeTrip.expenses) return 0;
          const total = this.activeTrip.expenses
                     .filter(exp => (exp.day === undefined ? 1 : exp.day) === dayIndex) 
                     .reduce((sum, item) => sum + (Number(item.amount) || 0), 0);
          return parseFloat(total.toFixed(2));
      },
      
      // ğŸ”¥ ç™»å…¥/è¨»å†Š/ç™»å‡ºæ–¹æ³•

      async loginUser() {
        if (!this.loginEmail || !this.loginPassword) return alert('è«‹è¼¸å…¥é›»å­éƒµä»¶å’Œå¯†ç¢¼');
        try {
            await auth.signInWithEmailAndPassword(this.loginEmail, this.loginPassword);
            this.showLoginModal = false;
        } catch (error) {
            // ç™»å…¥å¤±æ•—: {"error":{... "message":"API key not valid." ...}}
            console.error(error);
            alert('ç™»å…¥å¤±æ•—: ' + error.message);
        }
      },

      async logoutUser() {
        if(confirm('ç¢ºèªç™»å‡ºå—ï¼Ÿç™»å‡ºå¾Œå°‡ç„¡æ³•åŒæ­¥æ•¸æ“šã€‚')) {
            try {
                await auth.signOut();
                alert('æ‚¨å·²ç™»å‡ºã€‚');
                this.trips = [];
                this.activeTripId = null;
                this.showLoginModal = false; // ç™»å‡ºå¾Œé è¨­éš±è—
                this.loadInitialOrLocalData(false); // é‡æ–°è¼‰å…¥æœ¬åœ°æ•¸æ“š
            } catch (error) {
                alert('ç™»å‡ºå¤±æ•—: ' + error.message);
            }
        }
      },
      
      // === API åŠŸèƒ½ (åŒ¯ç‡ä¿®æ­£) ===

      // ğŸ”¥ æ–°å¢å°ˆé–€ç”¨æ–¼è¨˜å¸³é é¢æŠ“å–åŒ¯ç‡çš„æ–¹æ³•
      async fetchExchangeRate() {
        if (!this.activeTrip || !this.activeTrip.currency || this.activeTrip.currency === 'HKD') {
            return alert('è«‹å…ˆè¨­å®šç›®æ¨™åœ‹å®¶è²¨å¹£ (Currency)ï¼');
        }
        
        const currencyCode = this.activeTrip.currency;

        try {
             const rateRes = await fetch(`https://open.er-api.com/v6/latest/HKD`);
             const rateData = await rateRes.json();
             
             if (rateData?.rates && rateData.rates[currencyCode]) {
                const newRate = parseFloat(rateData.rates[currencyCode].toFixed(3));
                
                // ç›´æ¥æ›´æ–° activeTrip çš„åŒ¯ç‡
                this.activeTrip.exchangeRate = newRate;
                
                // åŒæ­¥æ›´æ–°æš«å­˜è®Šæ•¸
                this.tempExchangeRate = newRate; 

                this.saveData(); 
                alert(`æˆåŠŸï¼1 HKD â‰ˆ ${newRate} ${currencyCode}`);
             } else {
                 alert(`ç„¡æ³•å–å¾— ${currencyCode} çš„å³æ™‚åŒ¯ç‡ï¼Œè«‹æ‰‹å‹•è¼¸å…¥ã€‚`);
             }
        } catch (e) { 
          console.error("Rate fetch fail", e); 
          alert('å³æ™‚åŒ¯ç‡æœå‹™å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¼¸å…¥æˆ–ç¨å¾Œå†è©¦ã€‚');
        }
      },
      
      // ğŸ”¥ åŒ¯ç‡è¼¸å…¥æ¡†çš„ blur/Enter è™•ç†æ–¹æ³•
      updateExchangeRate() {
          const rate = Number(this.tempExchangeRate);
          if (isNaN(rate) || rate <= 0) {
              alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å­— (å¤§æ–¼ 0)');
              this.tempExchangeRate = this.activeTrip.exchangeRate || 1; // æ¢å¾©èˆŠå€¼
              return;
          }
          // æ›´æ–° activeTrip çš„å¯¦éš›å€¼
          this.activeTrip.exchangeRate = parseFloat(rate.toFixed(3));
          this.saveData();
      },

      async autoGeocode() {
        if (!this.tempTrip.city) return alert('è«‹å…ˆè¼¸å…¥åŸå¸‚åç¨± (City)');
        
        try {
          const geoRes = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${this.tempTrip.city},${this.tempTrip.destination || ''}&addressdetails=1&limit=1`);
          const geoData = await geoRes.json();
          if (!geoData || geoData.length === 0) {
            return alert('æ‰¾ä¸åˆ°è©²åŸå¸‚ï¼Œè«‹æª¢æŸ¥æ‹¼å­—ã€‚');
          }
          const location = geoData[0];
          this.tempTrip.center = { lat: parseFloat(location.lat), lng: parseFloat(location.lon) };
          if(location.address && location.address.country) {
             this.tempTrip.destination = location.address.country;
          }
          let currencyCode = 'USD';
          const countryCode = location.address?.country_code?.toUpperCase(); 
          if (countryCode) {
            try {
              const countryRes = await fetch(`https://restcountries.com/v3.1/alpha/${countryCode}`);
              const countryData = await countryRes.json();
              if (countryData[0]?.currencies) {
                currencyCode = Object.keys(countryData[0].currencies)[0];
                this.tempTrip.currency = currencyCode;
              }
            } catch (err) { console.error("Currency fetch fail", err); }
          }
          
          try {
             // åŒ¯ç‡æŠ“å–é‚è¼¯èˆ‡ fetchExchangeRate ç›¸åŒ
             const rateRes = await fetch(`https://open.er-api.com/v6/latest/HKD`);
             const rateData = await rateRes.json();
             if (rateData?.rates && rateData.rates[currencyCode]) {
                this.tempTrip.exchangeRate = parseFloat(rateData.rates[currencyCode].toFixed(3));
             } else {
                 this.tempTrip.exchangeRate = 1; 
             }
          } catch (err) { 
              console.error("Rate fetch fail", err); 
              this.tempTrip.exchangeRate = 1;
          }
          
          alert(`æˆåŠŸï¼\nåº§æ¨™: ${location.lat}, ${location.lon}\nåœ‹å®¶: ${this.tempTrip.destination}\nè²¨å¹£: ${currencyCode}\nåŒ¯ç‡: 1 HKD â‰ˆ ${this.tempTrip.exchangeRate.toFixed(2)} ${currencyCode}`);
        } catch (e) {
          console.error(e);
          alert('è‡ªå‹•å–å¾—å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚');
        }
      },
      async fetchFlight(type) {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥èˆªç­è³‡æ–™ã€‚");
            this.showLoginModal = true;
            return;
        }

        const flight = this.activeTrip.flights[type];
        if(!flight.no || !flight.date) return alert('è«‹å…ˆè¼¸å…¥èˆªç­è™Ÿ (å¦‚ NH924) èˆ‡æ—¥æœŸ');
        if(AVIATIONSTACK_KEY === '5bxxxxxxxxx') return alert('è«‹å°‡ AVIATIONSTACK_KEY æ›¿æ›ç‚ºæ‚¨çš„æœ‰æ•ˆ Keyï¼Œç›®å‰ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šï¼');
        
        try {
          const res = await fetch(`https://api.aviationstack.com/v1/flights?access_key=${AVIATIONSTACK_KEY}&flight_iata=${flight.no}&flight_date=${flight.date}`);
          const data = await res.json();
          if (data.data && data.data.length > 0) {
            const f = data.data[0]; 
            flight.from = f.departure.iata;
            flight.to = f.arrival.iata;
            flight.depTime = f.departure.scheduled ? f.departure.scheduled.slice(11,16) : '--:--';
            flight.arrTime = f.arrival.scheduled ? f.arrival.scheduled.slice(11,16) : '--:--';
            this.saveData();
            alert(`å·²æ›´æ–°èˆªç­: ${flight.from} -> ${flight.to}`);
          } else {
            alert('æœªæ‰¾åˆ°èˆªç­è³‡æ–™ï¼Œè«‹ç¢ºèª API Keyã€èˆªç­è™Ÿèˆ‡æ—¥æœŸã€‚');
             this.mockFlightData(type);
          }
        } catch(e) {
          console.error(e);
          alert('API è«‹æ±‚å¤±æ•—ï¼Œè«‹æª¢æŸ¥ Key æ˜¯å¦æ­£ç¢ºæˆ–ç¶²è·¯é€£ç·šã€‚ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šã€‚');
          this.mockFlightData(type);
        }
      },
      mockFlightData(type) {
          const flight = this.activeTrip.flights[type];
          const isOutbound = type === 'outbound';
          flight.from = isOutbound ? 'HKG' : 'NRT';
          flight.to = isOutbound ? 'NRT' : 'HKG';
          flight.depTime = isOutbound ? '09:00' : '14:30';
          flight.arrTime = isOutbound ? '14:30' : '20:30';
          this.saveData();
      },
      async fetchWeather() {
        if(!this.activeTrip?.center) return;
        try {
          const {lat,lng} = this.activeTrip.center;
          const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&timezone=auto`);
          const d = await res.json();
          this.weatherData = d.current_weather;
          
          const code = d.current_weather.weathercode;
          if (code < 3) { this.weatherTheme = 'sunny'; } 
          else if (code >= 51 && code < 80) { this.weatherTheme = 'rainy'; } 
          else { this.weatherTheme = 'cloudy'; } 
          
        } catch(e){
          console.error("Weather fetch failed", e);
          this.weatherData = { temperature: 20 + Math.floor(Math.random()*5), weathercode: 1 };
          this.weatherTheme = 'sunny';
        }
      },

      // === è¨˜å¸³åŠŸèƒ½ (é‡‘é¡è¼¸å…¥è™•ç†) ===
      
      // ã€å„ªåŒ–é»ã€‘ç¢ºä¿è¼¸å…¥æ¡†åªä¿ç•™æ•¸å­—å’Œå°æ•¸é»
      cleanAmountInput(event) {
          let cleaned = event.target.value.replace(/[^0-9.]/g, '');
          
          // åªä¿ç•™ç¬¬ä¸€å€‹å°æ•¸é»
          let parts = cleaned.split('.');
          if (parts.length > 2) {
              cleaned = parts[0] + '.' + parts.slice(1).join('');
          }
          
          this.newExpense.localAmount = cleaned;
      },
      
      // ğŸ”¥ é—œéµä¿®æ­£é» 2: å¼·åŒ– addExpense çš„é©—è­‰é‚è¼¯
      addExpense() {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è¨˜å¸³è¨˜éŒ„ã€‚");
            this.showLoginModal = true;
            return;
        }

        // æ­¥é©Ÿ 1: å¼·åˆ¶æ¸…ç†ä¸¦è½‰æ› localAmount
        const localAmountStr = String(this.newExpense.localAmount || '').replace(/[^0-9.]/g, '');
        const localAmount = Number(localAmountStr);
        
        // æ­¥é©Ÿ 2: å–å¾—æœ€çµ‚æ¸¯å¹£é‡‘é¡ (è¨ˆç®—å±¬æ€§ finalHKDAmount å·²åŒ…å«æ¸…ç†é‚è¼¯)
        const finalHKD = this.finalHKDAmount;
        
        // æ­¥é©Ÿ 3: åŸ·è¡Œé©—è­‰
        // é©—è­‰é‚è¼¯ï¼š
        // a. å¿…é ˆæœ‰æ¶ˆè²»é …ç›®åç¨±
        // b. localAmount å¿…é ˆæ˜¯æ•¸å­—ä¸”å¤§æ–¼ 0
        // c. å¦‚æœé¸æ“‡çš„æ˜¯å¤–å¹£ (éHKD)ï¼Œå‰‡ finalHKD å¿…é ˆæ˜¯æ•¸å­—ä¸”å¤§æ–¼ 0
        
        let isValid = true;
        if (!this.newExpense.name || isNaN(localAmount) || localAmount <= 0) {
            isValid = false; // é …ç›®åç¨±æˆ–ç•¶åœ°é‡‘é¡ç„¡æ•ˆ
        }
        
        // å¦‚æœä¸æ˜¯ HKDï¼Œå‰‡å¿…é ˆç¢ºä¿æ›ç®—å¾Œçš„ HKD é‡‘é¡å¤§æ–¼ 0
        if (this.inputCurrency !== 'HKD' && (isNaN(finalHKD) || finalHKD <= 0)) {
            isValid = false; // å¤–å¹£è½‰æ›å¤±æ•—æˆ–çµæœç‚º 0
        }
        
        if (!isValid) {
            // å¦‚æœé©—è­‰å¤±æ•—ï¼Œè¼¸å‡ºè©³ç´°éŒ¯èª¤è¨Šæ¯åˆ° Console ä¾›é™¤éŒ¯ç”¨
            console.error("Validation Failed:", {
                name: this.newExpense.name,
                localAmount: localAmount,
                finalHKD: finalHKD,
                inputCurrency: this.inputCurrency,
                isHKD: this.inputCurrency === 'HKD'
            });
            return alert('è«‹è¼¸å…¥æ¶ˆè²»é …ç›®å’Œæœ‰æ•ˆçš„é‡‘é¡ (è«‹ç¢ºä¿é‡‘é¡æ˜¯æ•¸å­—ä¸”å¤§æ–¼é›¶)');
        }
        
        // ã€æ–°å¢æª¢æŸ¥ã€‘ç¢ºä¿è²¨å¹£é¸æ“‡æ­£ç¢º
        if (!this.inputCurrency) {
             // ç†è«–ä¸Šé€™æ‡‰è©²ä¸æœƒç™¼ç”Ÿï¼Œå› ç‚º inputCurrency æœ‰é è¨­å€¼
             return alert('è«‹é¸æ“‡æœ‰æ•ˆçš„å¹£åˆ¥ (HKD æˆ–å¤–å¹£)ã€‚');
        }

        // æ­¥é©Ÿ 4: è™•ç†æ—…è¡Œå‰ Day 0 é‚è¼¯
        if (this.newExpense.category === 'æ—…è¡Œå‰') {
            this.newExpense.day = 0; 
        } else if (!this.newExpense.day || this.newExpense.day === 0) {
             if (this.newExpense.category !== 'æ—…è¡Œå‰') {
                 this.newExpense.day = 1;
             }
        }

        const d = new Date();
        
        // æ­¥é©Ÿ 5: æ–°å¢ expense
        this.newExpense.amount = finalHKD; 

        this.activeTrip.expenses.unshift({ 
            id: Date.now() + Math.random(), 
            name: this.newExpense.name,
            amount: this.newExpense.amount,
            method: this.newExpense.method,
            category: this.newExpense.category,
            localAmount: localAmount, 
            date: `${d.getMonth()+1}/${d.getDate()}`,
            day: this.newExpense.day, 
        });
        
        // æ­¥é©Ÿ 6: é‡ç½®
        this.newExpense = { 
            name:'', 
            localAmount:null, 
            amount:null, 
            method:'ç¾é‡‘', 
            category:'é£²é£Ÿ', 
            day: 1
        };
        // é‡ç½® inputCurrency ç‚º Trip é è¨­å¤–å¹£
        this.inputCurrency = this.activeTrip.currency; 
        this.saveData();
      },
      removeExpense(expenseId) {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è¨˜å¸³è¨˜éŒ„ã€‚");
            this.showLoginModal = true;
            return;
        }
        if(confirm('ç¢ºèªåˆªé™¤é€™ç­†æ¶ˆè²»å—ï¼Ÿ')) {
            const index = this.activeTrip.expenses.findIndex(exp => exp.id === expenseId);
            if (index !== -1) {
                this.activeTrip.expenses.splice(index, 1);
                this.saveData();
            }
        }
      },

      exportExpensesToCSV() {
          if (!this.activeTrip || !this.activeTrip.expenses.length) {
              return alert('ç›®å‰æ²’æœ‰æ¶ˆè²»è¨˜éŒ„å¯ä»¥åŒ¯å‡ºï¼');
          }
          
          const trip = this.activeTrip;
          
          const expensesToExport = this.activeTrip.expenses
              .slice() 
              .sort((a, b) => (a.day === undefined ? 1 : a.day) - (b.day === undefined ? 1 : b.day)); 

          if (expensesToExport.length === 0) {
              return alert(`æš«ç„¡æ¶ˆè²»è¨˜éŒ„å¯ä»¥åŒ¯å‡ºï¼`);
          }

          const headers = [
              "Day", "æ—¥æœŸ", "é …ç›®", "é¡åˆ¥", "æ”¯ä»˜æ–¹å¼", 
              `ç•¶åœ°é‡‘é¡ (${trip.currency})`, "åŒ¯ç‡ (1 HKD = X)", 
              "æ¸¯å¹£é‡‘é¡ (HKD)"
          ];
          
          const rows = expensesToExport.map(exp => [
              exp.day === 0 ? 'æ—…è¡Œå‰' : exp.day || 1, 
              exp.date || '',
              exp.name || '',
              exp.category || '',
              exp.method || '',
              (exp.localAmount || 0).toFixed(2),
              (trip.exchangeRate || 1).toFixed(2),
              (exp.amount || 0).toFixed(2) 
          ]);
          
          const csvContent = [
              headers.join(','),
              ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
          ].join('\n');
          
          const encodedUri = encodeURI("data:text/csv;charset=utf-8,\uFEFF" + csvContent);
          const link = document.createElement("a");
          
          const fileName = `${trip.title}_All_Expenses_${new Date().toISOString().split('T')[0]}.csv`;
          
          link.setAttribute("href", encodedUri);
          link.setAttribute("download", fileName);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          alert(`ã€Œ${fileName}ã€åŒ¯å‡ºæˆåŠŸï¼`);
      },

      updateChart() {
          if (this.activeTab !== 'budget') return;
          
          const summary = this.categorySummary;
          const ctx = document.getElementById('expenseChart');
          
          if (!ctx) return;

          const categoryColors = {
              'é£²é£Ÿ': '#FFD9EC', 
              'è³¼ç‰©': '#C7C7E2', 
              'äº¤é€š': '#97CBFF',
              'å¨›æ¨‚': '#A4D8B9', 
              'å…¶ä»–': '#F5E6CC',
              'æ—…è¡Œå‰': '#8A2BE2', 
          };
          
          const backgroundColors = summary.labels.map(label => 
              categoryColors[label] || '#97CBFF'
          );


          const chartData = {
              labels: summary.labels,
              datasets: [{
                  data: summary.data,
                  backgroundColor: backgroundColors,
                  hoverOffset: 10,
                  borderWidth: 0,
              }]
          };

          if (this.chartInstance) {
              this.chartInstance.data = chartData;
              this.chartInstance.update();
          } else {
              this.chartInstance = new Chart(ctx, {
                  type: 'doughnut',
                  data: chartData,
                  options: {
                      responsive: true,
                      maintainAspectRatio: false,
                      plugins: {
                          legend: {
                              position: 'bottom',
                              labels: {
                                  usePointStyle: true,
                                  boxWidth: 8,
                                  padding: 15,
                              }
                          },
                          tooltip: {
                              callbacks: {
                                  label: (context) => {
                                      let label = context.label || '';
                                      if (label) { label += ': '; }
                                      if (context.parsed !== null) {
                                          const total = summary.data.reduce((a, b) => a + b, 0);
                                          const percentage = (context.parsed * 100 / total).toFixed(1);
                                          label += `${context.parsed.toFixed(2)} HKD (${percentage}%)`;
                                      }
                                      return label;
                                  }
                              }
                          }
                      }
                  }
              });
          }
      },
      
      // === è³¼ç‰©åŠŸèƒ½ (åŠ å…¥ç™»å…¥æª¢æŸ¥) ===
      handleImageUpload(e) {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„åœ–ç‰‡è³‡æ–™ã€‚");
            this.showLoginModal = true;
            return;
        }
        const file = e.target.files[0];
        if (!file) return;
        if (file.size > 1024 * 1024) return alert('åœ–ç‰‡è«‹å°æ–¼ 1MB');
        const reader = new FileReader();
        reader.onload = (evt) => { this.newShoppingItem.image = evt.target.result; };
        reader.readAsDataURL(file);
      },
      addShoppingItem() {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è³¼ç‰©æ¸…å–®ã€‚");
            this.showLoginModal = true;
            return;
        }

        if(!this.newShoppingItem.name) return alert('è«‹è¼¸å…¥å“å');
        
        // å…è¨±åƒ¹æ ¼ç‚ºç©º
        const onlinePrice = Number(this.newShoppingItem.onlinePrice);
        const localPrice = Number(this.newShoppingItem.localPrice);

        this.activeTrip.shoppingItems.unshift({ 
            id: Date.now() + Math.random(), 
            onlinePrice: isNaN(onlinePrice) ? null : onlinePrice,
            localPrice: isNaN(localPrice) ? null : localPrice,
            quantity: Math.max(1, Number(this.newShoppingItem.quantity) || 1),
            bought: this.newShoppingItem.bought, 
            name: this.newShoppingItem.name,
            image: this.newShoppingItem.image
        }); 
        
        // é‡ç½®æ¬„ä½
        this.newShoppingItem = { name: '', onlinePrice: null, localPrice: null, quantity: 1, bought: false, image: '' };
        this.saveData();
      },
      
      // **é—œéµä¿®å¾© V4: æ¡ç”¨ Vue éŸ¿æ‡‰å¼æœ€ä½³å¯¦è¸ (splice æ›¿æ›æ–°ç‰©ä»¶) ä»¥ç¢ºä¿ç•«é¢æ›´æ–°**
      toggleBought(item) {
          if (!this.currentUser) {
              alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è³¼ç‰©æ¸…å–®ã€‚");
              this.showLoginModal = true;
              return;
          }
          if (!item || !this.activeTrip) return;

          // 1. æ‰¾åˆ°è©² item åœ¨ shoppingItems é™£åˆ—ä¸­çš„ç¢ºåˆ‡ç´¢å¼•
          const index = this.activeTrip.shoppingItems.findIndex(i => i.id === item.id);
          
          if (index !== -1) {
              // 2. æ›´æ”¹ bought ç‹€æ…‹
              const newBoughtState = !item.bought;

              // 3. å‰µå»ºä¸€å€‹æ–°çš„ç‰©ä»¶ä¾†æ›¿æ›èˆŠçš„ï¼Œç¢ºä¿ Vue åµæ¸¬åˆ°è®ŠåŒ–
              const newItem = { ...item, bought: newBoughtState };
              
              // 4. ä½¿ç”¨ splice æ›¿æ›èˆŠç‰©ä»¶
              this.activeTrip.shoppingItems.splice(index, 1, newItem);
              
              this.saveData(); 
              
              // 5. ç¢ºä¿ç¸½è¦½é é¢ç­‰ä¾è³´ä¹Ÿè¢«è§¸ç™¼ (éå¿…è¦ï¼Œä½†èƒ½æé«˜ç©©å®šæ€§)
              this.trips = [...this.trips]; 
          }
      },
      removeShoppingItem(itemId) {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è³¼ç‰©æ¸…å–®ã€‚");
            this.showLoginModal = true;
            return;
        }
        if(confirm('ç¢ºèªåˆªé™¤æ­¤è³¼ç‰©é …ç›®å—ï¼Ÿ')) {
            const index = this.activeTrip.shoppingItems.findIndex(item => item.id === itemId);
            if (index !== -1) {
                this.activeTrip.shoppingItems.splice(index, 1);
                this.saveData();
            }
        }
      },

      // === åœ°åœ–/è¡Œç¨‹åŠŸèƒ½ (åŠ å…¥ç™»å…¥æª¢æŸ¥) ===
      openGoogleMaps(item) { 
          if (item.mapLink && item.mapLink.trim()) {
              const url = item.mapLink.trim();
              if (url.startsWith('http')) {
                  window.open(url, '_blank');
              } else {
                  this.searchGoogleMaps(url);
              }
          } 
          else if (item.location && item.location.trim()) {
              this.searchGoogleMaps(item.location);
          } else {
              alert('è«‹è¼¸å…¥åœ°é»åç¨±æˆ–è²¼ä¸Š Google Map é€£çµã€‚');
          }
      },
      
      searchGoogleMaps(query) {
          const finalQuery = encodeURIComponent(query + ', ' + this.activeTrip.city);
          window.open(`https://www.google.com/maps/search/?api=1&query=${finalQuery}`, '_blank'); 
      },

      mapMarkers: L.layerGroup(),
      mapPolyline: null, 
      
      forceUpdateMap() {
        if (this.activeTab !== 'itinerary-map') return;
        try {
          const container = document.getElementById('map');
          // æª¢æŸ¥çˆ¶ç´šå…ƒç´ æ˜¯å¦å¯è¦‹ï¼Œé¿å…åœ¨éç•¶å‰ Tab æ¸²æŸ“æ™‚å¤±æ•—
          if (!container || container.offsetParent === null) {
              console.log("Map container not visible, skipping init.");
              return; 
          }
          if (this.map) { this.map.off(); this.map.remove(); }
          
          const center = this.activeTrip.center ? [this.activeTrip.center.lat, this.activeTrip.center.lng] : [35.6895, 139.6917];
          
          this.map = L.map('map', { zoomControl: false }).setView(center, 13);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap contributors' }).addTo(this.map);
          this.mapMarkers.clearLayers();
          this.mapMarkers.addTo(this.map);
          this.mapPolyline = L.polyline([], {color: '#97CBFF', weight: 4, opacity: 0.8, dashArray: '5, 10'}).addTo(this.map);
          
          this.updateMapMarkers(); 
          setTimeout(() => { this.map.invalidateSize(); }, 100);
        } catch (e) { console.error("Map init fail", e); }
      },
      
      async geocodeLocation(location) {
          if (GeocodingCache[location]) return GeocodingCache[location];
          
          try {
              const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}&limit=1`);
              const data = await res.json();
              if (data && data.length > 0) {
                  const coords = { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
                  GeocodingCache[location] = coords;
                  return coords;
              }
          } catch (e) {
              console.warn(`Geocoding failed for: ${location}. Error: ${e}. Route may not be drawn.`);
          }
          
          if (this.activeTrip.center) {
              // éš¨æ©Ÿåç§»ï¼Œæ¨¡æ“¬åœ°åœ–ä¸­å¿ƒé™„è¿‘
              return {
                  lat: this.activeTrip.center.lat + (Math.random() - 0.5) * 0.005,
                  lng: this.activeTrip.center.lng + (Math.random() - 0.5) * 0.005,
              };
          }
          return null; 
      },

      async updateMapMarkers() {
          if (!this.map || !this.activeTrip?.itinerary) return;
          this.mapMarkers.clearLayers();
          
          const currentDayItems = this.activeTrip.itinerary
              .filter(item => (item.day || 1) === this.activeDay && item.location) 
              .sort((a, b) => {
                  const timeA = a.time ? a.time.replace(':', '') : '9999';
                  const timeB = b.time ? b.time.replace(':', '') : '9999';
                  return timeA - timeB;
              });
          
          let lineCoords = [];
          let markers = [];
          
          for (let index = 0; index < currentDayItems.length; index++) {
              const item = currentDayItems[index];
              const fullLocation = item.location + ', ' + this.activeTrip.city + ', ' + this.activeTrip.destination; 
              const coords = await this.geocodeLocation(fullLocation);

              if (coords) {
                  lineCoords.push([coords.lat, coords.lng]); 

                  const marker = L.marker([coords.lat, coords.lng], {
                      icon: L.divIcon({
                          className: 'custom-div-icon',
                          html: `<div style="background-color:#97CBFF; color:white; border-radius:50%; width:24px; height:24px; line-height:24px; text-align:center; font-weight:bold;">${index + 1}</div>`,
                          iconSize: [24, 24],
                          iconAnchor: [12, 12]
                      })
                  }).bindPopup(`<b>Day ${item.day || 1} - ${item.location}</b><br>${item.activity}`);
                  markers.push(marker);
              }
          }

          markers.forEach(marker => this.mapMarkers.addLayer(marker));
          
          if (this.mapPolyline) {
              this.mapPolyline.setLatLngs(lineCoords);
          }
          
          if (this.mapMarkers.getLayers().length > 0) {
            this.map.fitBounds(this.mapMarkers.getBounds(), { padding: [50, 50] });
          } else if (this.activeTrip.center) {
             this.map.setView([this.activeTrip.center.lat, this.activeTrip.center.lng], 13);
          }
      },
      
      addItineraryItem(day) { 
          if (!this.currentUser) {
              alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è¡Œç¨‹ã€‚");
              this.showLoginModal = true;
              return;
          }
          this.activeTrip.itinerary.push({ 
              id: Date.now() + Math.random(), 
              day: day, 
              time: '10:00', 
              activity: '', 
              location: '',
              mapLink: '' 
          }); 
          this.saveData(); 
          this.forceUpdateMap();
      },
      
      removeItineraryItem(itemId) { 
          if (!this.currentUser) {
              alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è¡Œç¨‹ã€‚");
              this.showLoginModal = true;
              return;
          }
          if(confirm('ç¢ºèªåˆªé™¤æ­¤è¡Œç¨‹é …ç›®å—ï¼Ÿ')) {
              const index = this.activeTrip.itinerary.findIndex(item => item.id === itemId);
              if(index !== -1) {
                  this.activeTrip.itinerary.splice(index, 1);
                  this.saveData(); 
                  this.forceUpdateMap();
              }
          }
      },
      
      runBatchImport() {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥åŒæ­¥æ‚¨çš„è¡Œç¨‹ã€‚");
            this.showLoginModal = true;
            return;
        }

        if(!this.batchImportText) return alert('è«‹è²¼ä¸Šå…§å®¹');
        const lines = this.batchImportText.split('\n').filter(line => line.trim() !== '');
        
        const newItems = lines.map(line => {
            const parts = line.split(',');
            const dayNum = parseInt(parts[0]) || 1; 
            return {
                id: Date.now() + Math.random(), 
                day: dayNum > this.totalDays ? this.totalDays : dayNum,
                time: parts[1] ? parts[1].trim() : 'N/A',
                mapLink: '', 
                activity: parts[2] ? parts[2].trim() : 'æ´»å‹•',
                location: parts[3] ? parts[3].trim() : ''
            };
        });
        
        this.activeTrip.itinerary.push(...newItems);
        this.saveData();
        this.showBatchImport = false;
        this.batchImportText = '';
        this.forceUpdateMap(); 
        alert(`æˆåŠŸåŒ¯å…¥ ${newItems.length} æ¢è¡Œç¨‹ï¼`);
      },


      // === æ—…ç¨‹ç®¡ç†åŠŸèƒ½ (åŠ å…¥ç™»å…¥æª¢æŸ¥) ===
      openNewTripModal() { 
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥ç®¡ç†æ‚¨çš„æ—…ç¨‹ã€‚");
            this.showLoginModal = true;
            return;
        }
        this.editingTripId = null; 
        this.tempTrip = {
            title:'', city:'', destination:'', currency:'JPY', exchangeRate:19.2, 
            center:{lat:35.6,lng:139.6}, 
            startDate: new Date().toISOString().split('T')[0], 
            endDate: new Date().toISOString().split('T')[0]
        }; 
        this.showTripModal = true; 
      },
      openEditTripModal(trip) { 
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥ç®¡ç†æ‚¨çš„æ—…ç¨‹ã€‚");
            this.showLoginModal = true;
            return;
        }
        this.editingTripId = trip.id; this.tempTrip = JSON.parse(JSON.stringify(trip)); this.showTripModal = true; 
      },
      saveTrip() {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥å„²å­˜æ‚¨çš„æ—…ç¨‹ã€‚");
            this.showLoginModal = true;
            return;
        }

        if (!this.tempTrip.title) return;
        if (this.editingTripId) {
          const idx = this.trips.findIndex(t => t.id === this.editingTripId);
          this.trips[idx] = { ...this.trips[idx], ...this.tempTrip };
        } else {
          const center = this.tempTrip.center || {lat:35.6, lng:139.6};
          const newTrip = { 
            id: Date.now(), 
            ...this.tempTrip, 
            center: center, 
            flights:{outbound:{},inbound:{}}, 
            itinerary:[], 
            expenses:[], 
            shoppingItems:[] 
          };
          this.trips.unshift(newTrip); 
          this.activeTripId = newTrip.id;
        }
        this.saveData();
        this.showTripModal = false;
        
        this.$nextTick(() => {
            this.activeDay = 1;
            this.newExpense.day = 1; 
            this.newExpense.category = 'é£²é£Ÿ'; 
            this.inputCurrency = this.activeTrip.currency;
            // åŒæ­¥ tempExchangeRate
            this.tempExchangeRate = this.activeTrip.exchangeRate; 
            this.updateChart();
        });
      },
      deleteTrip(id) {
        if (!this.currentUser) {
            alert("è«‹å…ˆç™»å…¥ä»¥ç®¡ç†æ‚¨çš„æ—…ç¨‹ã€‚");
            this.showLoginModal = true;
            return;
        }
        if(this.trips.length<=1) return alert('ä¸èƒ½åˆªé™¤æœ€å¾Œä¸€å€‹æ—…ç¨‹');
        if(confirm('ç¢ºèªåˆªé™¤?')) {
          this.trips = this.trips.filter(t=>t.id!==id);
          this.activeTripId = this.trips[0].id;
          this.saveData();
        }
      },
      switchTrip(id) { 
        this.activeTripId = id; 
        this.activeTab = 'info'; 
        this.$nextTick(() => {
            this.activeDay = 1;
            this.newExpense.day = 1; 
            this.newExpense.category = 'é£²é£Ÿ'; 
            this.inputCurrency = this.activeTrip.currency;
            // åŒæ­¥ tempExchangeRate
            this.tempExchangeRate = this.activeTrip.exchangeRate; 
            this.updateChart();
        });
      },
    }
  }).mount('#app');
</script>
